よろしくおねがいします

本当はTwitter Botをフルスクラッチで実装する話をするつもりだったんですけど、
内容か完全に形態素解析器の実装の話になってしまいました。

簡単な自己紹介ですが、香川高専の電気科で5年生をしています。
詫間じゃなくて高松の方です。
今日のお品書きはTwitter Botの概要、bi-gramマルコフモデルを採用した形態素の解説、
実装に必要になる高速なTrie木とLatice解析となっています。

でまずTwitter Botですね。実装したことのある人にとっては釈迦に説法になると思いますが、
だいたいこんな感じです。
学習元の文章をMeCabなどで分かち書きしてデータを加工し、
MongoDBなどのDBに格納して、そこからデータを引っ張りながらマルコフ連鎖で文章を生成し、Twitterに登校していきます。
今回は通信周りの話ではなく言語処理の話だけしていきます。

文章を生成する前に分かち書きをして元データを生成しておきます。
こんな感じに形態素毎に区切り、一定数nずつの塊にしてDBに格納します。

こうして作成した大量のデータをランダムに選択しながらしりとりをしていきます。
ちなみにBOSがBegin Of Sequence、EOSがEnd Of Sequenceです。
これ以降も出てきます。
この3つの塊は全て別々の文章から抜き出したものですが、
繋げて読むと「オススメのうどん食べてなかった」となりかなり自然な分になっていますよね。

でこれ何処にマルコフが関係して来るのかを離す前にマルコフ連鎖の定義を出します。

まず現在の状態のみで未来への遷移が決まること、そして離散的な状態を取ることです。
前者はマルコフ性と名前が付いていて、自然界では結構見られる特性です。
例えば原子核の崩壊、これって過去とは無関係に一定の確率で崩壊しますよね。
あと双六、これも前回進んだ距離と今回サイコロを降って進む距離は一切関係無いはずです。
いかさまをしていなければ。
この例だと双六は離散的に状態が変化するのでマルコフ連鎖、原子核の崩壊は連続的に状態が変わるので、
マルコフ性はあるがマルコフ連鎖ではありません。

ここで先の文章生成アルゴリズムを見てみると、コンテキストが考慮されておらず、
次の塊は現在の塊の最後尾の形態素のみに依存して決まること、
塊の数は自然数であり、連続的な値を取らない、まあ当たり前ですね。とこの事からマルコフ性を満たすことが分かります。
お気づきのようにマルコフ連鎖は文書生成のみならず非情に広い範囲で見られます。オートマトンとかも完全にこれですね。

文章生成アルゴリズムが分かったところで、学習元データとAPIラッパ、DB、形態素解析器があればBotを実装できるようになったわけですが、
ここに出てくるものってライブラリに頼らなくても自力で実装できそうだと思いませんか。
APIラッパも機能を制限すれば実装できそうだし、DBも一致でさえ検索できれば良いのでこれも難しく無さそうです。
形態素解析器も実装できる気がしますね。

さてモチベーションが湧いたところで本題の形態素解析アルゴリズムの話に入るんですが、
実は結構単純です。
まず辞書を引きながら、あり得る可能性を全て列挙します。ちなみに列挙した経路の事をLaticeと言います。
で、その列挙した経路を見てその経路に含まれる形態素の生起コスト、単語の出現しやすさと、
連接コスト、形態素と形態素の繋がりやすさでLaticeのコストを求め、最も低コストな経路を形態素解析結果とします。
ちなみに説明の上では列挙と探索は別なのですが、実際は並行して計算されます。

百聞は一見に如かずということでこの図を見てください。
これは「東京都に住む」という文のLaticeを表した図なのですが、結構候補がありますね。
「とうきょうと」以外にも「ひがしきょうと」なども候補として考えられていると解ると思います。

これのコストを計算すると図のようになります。直感とも合っていますね。
とまあこれだけなら非情に単純なのですが、大量の単語を辞書から引く上、文が長いと探索空間も大きくなるので
単純に実装していたのではメモリも時間も足りません。
まずは辞書から単語を引く部分について話します。

結論から言うとTrie木を使います。競プロerの皆さんなら知っていると思いますが、これは中々優秀なデータ構造で、
時間計算量がデータ量に依らずキーにのみ依ります。
nが大体46万とかになるのでにぶたんとかだと不安なんですよね。
trie木の実装法は幾つかあるのですが、ここでは配列を使った方法で実装します。
MeCabと同じですね。

まず先程のTrie木のノードに一意なIDを降っておきます。
そして状態と入力をキーにした状態遷移表を考えます。

こんな感じですね。先の図での5の状態なら、lが来れば6に、mが来れば7に遷移します。
この時に文字コードをそのまま整数値としてインデックスに使えば非常に高速に遷移できます。
LR法とかで出てくる表に似ていますね。まあ実際似たようなものです。

ただ問題があり、とにかくスッカスカと言うことです。
富豪的プログラミングどころか愚直にやると200GBとか必要になってきます。
石油王どころの騒ぎじゃない。

というわけで圧縮していきます。
まず先程の表の各行を少しづつずらし、重ね合わせていきます。
この時にずらした量を親ノードが覚えておきます。ちなみにBASEと言います。
そして行が混じったので、親を間違える可能性があります。
そこで自分の親を覚えておき、照合して親が正しいかを確認します。これがCHECKです。
このデータ構造をDouble Arrayと呼びます。
この圧縮はかなり疎な行が多いため割と適当にやってもそこそこ詰まります。
ただ圧縮それ自体はナイーブな実装だとO(n)になるのでそこは最適化が必要です。

で最後のLaticeのコスト計算の話です。取りうる可能性を列挙しつつコストを計算するだけなのですが、
実は個々も最適化の余地があります。
「に」に注目してください。これ「に」までの最小コストの経路って「に」以降と独立に求められますよね。
つまり部分問題を解くことで問題全体を解くことが出来ます。
競プロerの皆さんはピンときたと思いますが、そうですDPです。動的計画法。
時間計算量はnの自乗です。ちょっと大きいように見えますが、まあ1つの文章につき高々一回なので大した問題ではないです。

かなり駆け足になってしまいましたが、皆さんも形態素解析器って案外作れるんじゃねと思って頂けたら幸いです。
Twitter Botの次は形態素解析器自作を流行らせていきましょう。
