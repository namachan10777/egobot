% -*- coding: utf-8 -*-
@require: steamer
@require: gr
@require: itemize
@require: vdecoset
@require: tabular


Steamer.document(|
  title = {形態素解析器をフルスクラッチで作る話};
  author = {Nakano Masaki};
  institute = {香川高専 電気情報工学科5年};
  date = {Wed 1\textsuperscript{th} May, 2019};
  show-title = false;
  show-toc = false;
|) '<
  +section {タイトル} <
    +make-title{Twitter Botをフルスクラッチで作る話}{Nakano Masaki}{香川高専 電気情報工学科5年}{Wed 1\textsuperscript{th} May, 2019}
    +make-title{\sout{Twitter Botをフルスクラッチで作る話}}{Nakano Masaki}{香川高専 電気情報工学科5年}{Wed 1\textsuperscript{th} May, 2019}
    +make-title{形態素解析器をフルスクラッチで作る話}{Nakano Masaki}{香川高専 電気情報工学科5年}{Wed 1\textsuperscript{th} May, 2019}
    +frame ?:({自己紹介と今日の話題})<
      +listing {
        * 中野将生(なかの まさき)
        * 香川高専 電気情報工学科 4年
        * 本題
          ** Twitter Botの典型的な実装
          ** bi-gramマルコフモデルの形態素解析器のアルゴリズム
          ** 高速なTrie木とLatice解析の実装
      }
    >
    +frame-nc ?:({Twitter Bot})<
      +p-center{\insert-pdf(7cm)(`./fig/twitterbot.pdf`)(1);}
    >
    +frame-nc ?:({文章生成の詳細})<
      +listing {
        * 形態素n個で切り出す
      }
      +p-center{
        \insert-pdf(9cm)(`./fig/npair.pdf`)(1);
      }
    >
    +frame-nc ?:({文章生成の詳細})<
      +listing {
        * しりとりをする
      }
      +p-center{
        \insert-pdf(8cm)(`./fig/chain.pdf`)(1);
      }
    >
    +frame-nc ?:({マルコフ連鎖とは?})<
      +listing {
        * 過去と関係なく、現在の状態のみで未来への遷移が決まる
        * 離散的な状態を取る
      }
      +centered-pdf(6.5cm)(`./fig/markov.pdf`)(1);
    >
    +frame ?:({文章生成の詳細})<
      +listing {
        * 文脈を考慮しないしりとりなので、次のnつ組は現在のnつ組の最後の形態素で決まる(マルコフ性)
        * nつ組みの個数は自然数個であり、連続的な値を取らない(離散的)
      }
      +p {
       \emph{つまりマルコフ連鎖}
      }
    >
    +frame ?:({必要なもの})<
      +listing {
        * 学習元
        * Twitter APIとの通信
        * 3つ組みを格納するDB
        * 形態素解析器
      }
    >
    +frame ?:({必要なもの})<
      +listing {
        * 学習元(オタクなのでツイート数には困らない)
        * Twitter APIとの通信(書いている人は多い)
        * 3つ組みを格納するDB(要求が単純でデータも精々MB単位)
        * 形態素解析器(実は実装できる)
      }
      +p{
        ${\to}実装できるのでは?
      }
    >
    +frame-nc ?:({形態素解析器の基本的なアルゴリズム})<
      +listing{
        * 辞書を引きながら候補(Latice)を列挙する
        * 生起コスト(単語の出現しやすさ)と連接コスト(単語の繋がりやすさ)を考慮して最短経路を求める
          ** 実際はLatice構築と探索は並行して行う
      }
    >
    +frame-nc ?:({形態素解析器の基本的なアルゴリズム})<
      +p-center {
        \insert-pdf(10cm)(`./fig/latice.pdf`)(1);
      }
    >
    +frame-nc ?:({形態素解析器の基本的なアルゴリズム})<
      +p-center {
        \insert-pdf(10cm)(`./fig/latice-highlight.pdf`)(1);
      }
    >
    +frame-nc ?:({Trie木})<
      +p-center {
        \insert-pdf(5cm)(`./fig/trie.pdf`)(1);
      }
    >
    +frame-nc ?:({Trie木})<
      +listing {
        * キーの長さを${k}、データの数を${n}とする
        * 時間計算量は理想的には${\mathrm{O}\(k\)}
        * \emph{木構造ではなく二次元配列で実装}
          ** ヒープを使った単純な木の実装では非常に低速
      }
    >
    +frame-nc ?:({Trie木})<
      +p-center {
        \insert-pdf(5cm)(`./fig/trie-with-id.pdf`)(1);
      }
    >
    +frame-nc ?:({遷移表})<
      +listing {
        * 状態に一意なIDを振る
        * 状態と入力をキーにする遷移先を書き込んだ表を考える
        * 表を使い状態と入力から${\mathrm{O} \(1\)}で遷移すれば高速
        * 幸い文字コードは整数値で表現できる
      }
    >
    +frame-nc ?:({遷移表})<
      +p-center{
        \tabular(fun ce multif empty -> [
          [ce {状態}; multif 1 8 {入力}; empty; empty; empty; empty; empty; empty];
          [empty; ce{f}; ce{i}; ce{s}; ce{h}; ce{l}; ce{m}; ce{k}; ce{n}; ce{o}; ce{w};];
          [ce{1}; empty; ce{2}; empty; empty; empty; empty; empty; empty; empty; empty];
          [ce{2}; empty; empty; ce{3}; empty; ce{5}; empty; empty; empty; empty; empty];
          [ce{3}; empty; empty; empty; ce{4}; empty; empty; empty; empty; empty; empty];
          [ce{4}; empty; empty; empty; empty; empty; empty; empty; empty; empty; empty];
          [ce{5}; empty; empty; empty; empty; ce{6}; ce{7}; empty; empty; empty; empty];
          [ce{6}; empty; empty; empty; empty; empty; empty; empty; empty; empty; empty];
          [ce{7}; empty; empty; empty; empty; empty; empty; empty; empty; empty; empty];
          [ce{8}; empty; empty; empty; empty; empty; empty; ce{9}; empty; empty; empty];
          [ce{9}; empty; empty; empty; empty; empty; empty; empty; ce{10}; empty; empty];
          [ce{10}; empty; empty; empty; empty; empty; empty; empty; empty; ce{11}; empty];
          [ce{11}; empty; empty; empty; empty; empty; empty; empty; empty; empty; empty];
        ])(fun xs ys ->(
          let bold p1 p2 = stroke 1pt Color.black (Gr.line p1 p2) in
          let thin p1 p2 = stroke 0.5pt Color.black (Gr.line p1 p2) in
          match (ys, List.reverse ys) with
          | (y0 :: y1 :: y2 :: _, ylast :: _) ->
            (match (xs, List.reverse xs) with
            | (x0 :: x1 :: _, xlast :: _) ->
              (bold (x0, y0) (xlast, y0))
              :: (bold (x0, ylast) (xlast, ylast))
              :: (bold (x0, y0) (x0, ylast))
              :: (bold (xlast, y0) (xlast, ylast))
              :: (thin (x1, y1) (xlast, y1))
              :: (thin (x1, y0) (x1, ylast))
              :: (thin (x0, y2) (xlast, y2))
              :: []
            )
          ));
      }
    >
    +frame-nc ?:({問題点})<
      +listing {
        * スッッカスカ
        * メモリの無駄遣い(実際愚直にやると${200\ \mathrm{GB}}くらい必要)
      }
    >
    +frame-nc ?:({解決策})<
      +listing {
        * 遷移表を圧縮する
          ** 行ごとに少しづつずらして重ね合わせる(BASE)
          ** 別の行と混同しないよう親の位置を覚えておく(CHECK)
        * 圧縮は割と適当でもそこそこ詰まる
        * 圧縮は工夫しないと追加に${\mathrm{O} \( n \)}が必要
      }
    >
    +frame-nc ?:({Latice})<
      +p-center {
        \insert-pdf(7cm)(`./fig/darray.pdf`)(1);
      }
    >
    +frame-nc ?:({Latice})<
      +p-center {
        \insert-pdf(10cm)(`./fig/latice.pdf`)(1);
      }
    >
    +frame-nc ?:({Latice})<
      +listing {
        * マルコフ性より過去の形態素は考慮しなくていい
          ** 部分和問題を解けばコストを計算できる
          ** DPで解ける
          ** 文章長を${n}とすると${\mathrm{O} \( n^2 \)}(本当はちょっと違う)
      }
    >

    +frame-nc <
      +p-center{
        \emph{
          ありがとうございました
        }
      }
    >
  >
>
